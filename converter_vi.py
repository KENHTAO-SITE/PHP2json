#!/usr/bin/env python3
"""
Robust PHP Language Files to JSON Converter - Vietnamese Version
===============================================================
C√¥ng c·ª• c·∫£i ti·∫øn ƒë·ªÉ chuy·ªÉn ƒë·ªïi PHP sang JSON an to√†n v√† to√†n di·ªán

T√≠nh nƒÉng:
- Nhi·ªÅu chi·∫øn l∆∞·ª£c parsing v·ªõi fallbacks
- Logging l·ªói chi ti·∫øt v√† validation
- X·ª≠ l√Ω ch·∫≠m h∆°n, an to√†n h∆°n cho b·ªô file l·ªõn
- H·ªó tr·ª£ c·∫•u tr√∫c PHP n√¢ng cao
- Ph√¢n t√≠ch file to√†n di·ªán tr∆∞·ªõc khi convert
"""

import os
import re
import json
import sys
import time
from pathlib import Path
from typing import Dict, Any, Optional, Tuple, List

class RobustPHPToJSONConverter:
    def __init__(self):
        self.root_dir = Path.cwd()
        self.php_files = []
        self.converted_count = 0
        self.failed_count = 0
        self.deleted_count = 0
        self.failed_files = []
        self.processing_delay = 0.1  # Delay nh·ªè gi·ªØa c√°c files ƒë·ªÉ an to√†n

    def find_php_files_recursive(self, skip_existing=True):
        """T√¨m t·∫•t c·∫£ file .php v·ªõi ph√¢n t√≠ch chi ti·∫øt"""
        self.php_files = []

        print("üîç ƒêang qu√©t th∆∞ m·ª•c t√¨m file PHP...")
        for php_file in self.root_dir.rglob("*.php"):
            if php_file.name in ["converter_en.py", "converter_vi.py", "load_json_example.php"]:
                continue

            if skip_existing:
                json_file = php_file.with_suffix('.json')
                if json_file.exists():
                    print(f"‚è≠Ô∏è  B·ªè qua {php_file.relative_to(self.root_dir)} (JSON ƒë√£ t·ªìn t·∫°i)")
                    continue

            self.php_files.append(php_file)

        print(f"üìä T√¨m th·∫•y {len(self.php_files)} file PHP ƒë·ªÉ x·ª≠ l√Ω")
        return len(self.php_files)

    def analyze_php_file(self, php_file: Path) -> Dict[str, Any]:
        """Ph√¢n t√≠ch c·∫•u tr√∫c file PHP tr∆∞·ªõc khi convert"""
        try:
            with open(php_file, 'r', encoding='utf-8') as f:
                content = f.read()

            analysis = {
                'file_size': len(content),
                'line_count': content.count('\n') + 1,
                'has_php_tags': '<?php' in content or '<?=' in content,
                'has_return_statement': re.search(r'\breturn\s+', content, re.IGNORECASE) is not None,
                'has_variable_assignment': re.search(r'\$\w+\s*=', content) is not None,
                'array_syntax': [],
                'variable_names': [],
                'encoding': 'utf-8'
            }

            # Ph√°t hi·ªán lo·∫°i array syntax
            if re.search(r'\[.*?\]', content, re.DOTALL):
                analysis['array_syntax'].append('short_array')
            if re.search(r'array\s*\(', content, re.IGNORECASE):
                analysis['array_syntax'].append('long_array')

            # Tr√≠ch xu·∫•t t√™n bi·∫øn
            var_matches = re.findall(r'\$(\w+)\s*=', content)
            analysis['variable_names'] = list(set(var_matches))

            return analysis

        except Exception as e:
            return {'error': str(e)}

    def parse_php_array_robust(self, content: str) -> Optional[Dict[str, Any]]:
        """Parsing PHP ƒëa chi·∫øn l∆∞·ª£c v·ªõi fallbacks to√†n di·ªán"""

        # Chi·∫øn l∆∞·ª£c 1: Advanced regex v·ªõi h·ªó tr·ª£ nested structure
        result = self._parse_strategy_advanced_regex(content)
        if result and len(result) > 0:
            return result

        # Chi·∫øn l∆∞·ª£c 2: Tokenizer gi·ªëng PHP
        result = self._parse_strategy_tokenizer(content)
        if result and len(result) > 0:
            return result

        # Chi·∫øn l∆∞·ª£c 3: Line-by-line v·ªõi state machine
        result = self._parse_strategy_state_machine(content)
        if result and len(result) > 0:
            return result

        # Chi·∫øn l∆∞·ª£c 4: Regex v·ªõi x·ª≠ l√Ω nested th·ªß c√¥ng
        result = self._parse_strategy_manual_nested(content)
        if result and len(result) > 0:
            return result

        return None

    def _parse_strategy_advanced_regex(self, content: str) -> Optional[Dict[str, Any]]:
        """Chi·∫øn l∆∞·ª£c 1: Advanced regex parsing"""
        try:
            # L√†m s·∫°ch content
            content = self._clean_php_content(content)

            # M·ªü r·ªông patterns cho c√°c c·∫•u tr√∫c PHP kh√°c nhau
            patterns = [
                r'return\s*\[(.*?)\];',
                r'return\s*array\s*\((.*?)\);',
                r'\$(?:lang|language|data|translations|messages|text|strings)\s*=\s*\[(.*?)\];',
                r'\$(?:lang|language|data|translations|messages|text|strings)\s*=\s*array\s*\((.*?)\);',
            ]

            for pattern in patterns:
                match = re.search(pattern, content, re.DOTALL | re.IGNORECASE)
                if match:
                    array_content = match.group(1)
                    result = self._parse_array_content_advanced(array_content)
                    if result:
                        return result

        except Exception as e:
            print(f"   ‚ö†Ô∏è  Chi·∫øn l∆∞·ª£c 1 th·∫•t b·∫°i: {e}")

        return None

    def _parse_strategy_tokenizer(self, content: str) -> Optional[Dict[str, Any]]:
        """Chi·∫øn l∆∞·ª£c 2: Tokenizer approach"""
        try:
            content = self._clean_php_content(content)
            result = {}

            # T√¨m ƒëi·ªÉm b·∫Øt ƒë·∫ßu array
            array_start = None
            for pattern in [r'return\s*\[', r'return\s*array\s*\(', r'\$\w+\s*=\s*\[', r'\$\w+\s*=\s*array\s*\(']:
                match = re.search(pattern, content, re.IGNORECASE)
                if match:
                    array_start = match.end()
                    break

            if array_start is None:
                return None

            # Tr√≠ch xu·∫•t key-value pairs v·ªõi parsing t·ªët h∆°n
            remaining_content = content[array_start:]

            # S·ª≠ d·ª•ng regex c·∫£i ti·∫øn cho key-value extraction
            kv_pattern = r"""
                (?:^|,|\n)\s*                    # B·∫Øt ƒë·∫ßu ho·∫∑c separator
                (['\"])((?:\\.|(?!\1)[^\\])*?)\1  # Quoted key
                \s*=>\s*                         # M≈©i t√™n
                (?:
                    (['\"])((?:\\.|(?!\3)[^\\])*?)\3  # Quoted value
                    |
                    (\d+(?:\.\d+)?)              # S·ªë
                    |
                    (true|false|null)            # Boolean/null
                    |
                    (\[(?:[^\[\]]|(?7))*\])      # Simple nested array
                )
            """

            matches = re.finditer(kv_pattern, remaining_content, re.VERBOSE | re.DOTALL | re.IGNORECASE)

            for match in matches:
                groups = match.groups()
                if len(groups) >= 4:
                    key = self._clean_string_value(groups[1])

                    # X√°c ƒë·ªãnh value
                    if groups[3]:  # String value
                        value = self._clean_string_value(groups[3])
                    elif groups[4]:  # Number
                        value = groups[4]
                    elif groups[5]:  # Boolean/null
                        value = groups[5].lower()
                    elif groups[6]:  # Nested array
                        value = groups[6]  # Gi·ªØ d∆∞·ªõi d·∫°ng string t·∫°m th·ªùi
                    else:
                        continue

                    result[key] = value

            return result if result else None

        except Exception as e:
            print(f"   ‚ö†Ô∏è  Chi·∫øn l∆∞·ª£c 2 th·∫•t b·∫°i: {e}")

        return None

    def _parse_strategy_state_machine(self, content: str) -> Optional[Dict[str, Any]]:
        """Chi·∫øn l∆∞·ª£c 3: State machine line-by-line parsing"""
        try:
            content = self._clean_php_content(content)
            lines = content.split('\n')
            result = {}

            in_array = False
            current_key = None
            current_value = ""
            bracket_count = 0
            quote_char = None

            for line_no, line in enumerate(lines, 1):
                line = line.strip()

                if not line or line.startswith('//') or line.startswith('/*'):
                    continue

                # B·∫Øt ƒë·∫ßu array
                if not in_array and ('=>' in line or re.search(r'return\s*[\[\(]|^\$\w+\s*=\s*[\[\(]', line)):
                    in_array = True

                if not in_array:
                    continue

                # X·ª≠ l√Ω d√≤ng cho key-value pairs
                if '=>' in line and current_key is None:
                    parts = line.split('=>', 1)
                    if len(parts) == 2:
                        key_part = parts[0].strip()
                        value_part = parts[1].strip()

                        # Tr√≠ch xu·∫•t key
                        key_match = re.search(r"['\"]([^'\"]*)['\"]", key_part)
                        if key_match:
                            current_key = self._clean_string_value(key_match.group(1))

                            # Tr√≠ch xu·∫•t value
                            value_match = re.search(r"['\"]([^'\"]*)['\"]", value_part)
                            if value_match:
                                result[current_key] = self._clean_string_value(value_match.group(1))
                                current_key = None
                            else:
                                # Multi-line value c√≥ th·ªÉ ƒëang b·∫Øt ƒë·∫ßu
                                current_value = value_part

            return result if result else None

        except Exception as e:
            print(f"   ‚ö†Ô∏è  Chi·∫øn l∆∞·ª£c 3 th·∫•t b·∫°i: {e}")

        return None

    def _parse_strategy_manual_nested(self, content: str) -> Optional[Dict[str, Any]]:
        """Chi·∫øn l∆∞·ª£c 4: X·ª≠ l√Ω nested structure th·ªß c√¥ng"""
        try:
            content = self._clean_php_content(content)
            result = {}

            # T√¨m t·∫•t c·∫£ top-level key-value pairs
            # Regex n√†y x·ª≠ l√Ω nested structures b·∫±ng c√°ch ƒë·∫øm brackets
            pattern = r"""
                (['\"])((?:\\.|(?!\1)[^\\])*?)\1    # Key trong quotes
                \s*=>\s*                            # M≈©i t√™n
                (?:
                    (['\"])((?:\\.|(?!\3)[^\\])*?)\3 # Simple quoted value
                    |
                    (\d+(?:\.\d+)?)                 # Numeric value
                    |
                    (true|false|null)               # Boolean/null
                    |
                    (\[(?:[^\[\]]++|(?7))*+\])      # Nested array (possessive)
                )
            """

            matches = re.finditer(pattern, content, re.VERBOSE | re.DOTALL | re.IGNORECASE)

            for match in matches:
                try:
                    key_quote, key, value_quote, value, numeric, boolean, nested = match.groups()

                    clean_key = self._clean_string_value(key)

                    if value is not None:
                        clean_value = self._clean_string_value(value)
                    elif numeric is not None:
                        clean_value = numeric
                    elif boolean is not None:
                        clean_value = boolean.lower()
                    elif nested is not None:
                        # Th·ª≠ parse nested array ho·∫∑c gi·ªØ d∆∞·ªõi d·∫°ng string
                        clean_value = self._parse_nested_array(nested) or nested
                    else:
                        continue

                    result[clean_key] = clean_value

                except Exception as e:
                    print(f"   ‚ö†Ô∏è  L·ªói parsing match: {e}")
                    continue

            return result if result else None

        except Exception as e:
            print(f"   ‚ö†Ô∏è  Chi·∫øn l∆∞·ª£c 4 th·∫•t b·∫°i: {e}")

        return None

    def _clean_php_content(self, content: str) -> str:
        """L√†m s·∫°ch PHP content ƒë·ªÉ parsing"""
        # X√≥a PHP tags
        content = re.sub(r'<\?php\s*', '', content)
        content = re.sub(r'\?>', '', content)

        # X√≥a comments (c·∫£i ti·∫øn)
        content = re.sub(r'//.*?$', '', content, flags=re.MULTILINE)
        content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
        content = re.sub(r'#.*?$', '', content, flags=re.MULTILINE)

        return content.strip()

    def _clean_string_value(self, value: str) -> str:
        """L√†m s·∫°ch string value b·∫±ng c√°ch x√≥a escapes"""
        if not value:
            return value

        # X·ª≠ l√Ω escaped quotes
        value = value.replace('\\"', '"')
        value = value.replace("\\'", "'")
        value = value.replace('\\\\', '\\')

        return value

    def _parse_nested_array(self, nested_content: str) -> Optional[str]:
        """Parse nested array content"""
        # T·∫°m th·ªùi tr·∫£ v·ªÅ d∆∞·ªõi d·∫°ng formatted string
        # C√≥ th·ªÉ enhance ƒë·ªÉ return actual nested dict
        try:
            # L√†m s·∫°ch nested content
            nested_content = nested_content.strip('[]()').strip()
            return nested_content
        except:
            return None

    def _parse_array_content_advanced(self, array_content: str) -> Optional[Dict[str, Any]]:
        """Advanced array content parsing"""
        result = {}

        try:
            # X·ª≠ l√Ω multi-line entries t·ªët h∆°n
            # Split b·∫±ng commas nh∆∞ng t√¥n tr·ªçng quotes v√† nested structures
            entries = self._smart_split_array_entries(array_content)

            for entry in entries:
                entry = entry.strip()
                if not entry or entry.startswith('//'):
                    continue

                if '=>' in entry:
                    parts = entry.split('=>', 1)
                    if len(parts) == 2:
                        key_part = parts[0].strip()
                        value_part = parts[1].strip()

                        # Tr√≠ch xu·∫•t key
                        key_match = re.search(r"['\"]([^'\"]*)['\"]", key_part)
                        if key_match:
                            key = self._clean_string_value(key_match.group(1))

                            # Tr√≠ch xu·∫•t value
                            value_match = re.search(r"['\"]([^'\"]*)['\"]", value_part)
                            if value_match:
                                value = self._clean_string_value(value_match.group(1))
                                result[key] = value

        except Exception as e:
            print(f"   ‚ö†Ô∏è  Advanced parsing th·∫•t b·∫°i: {e}")

        return result if result else None

    def _smart_split_array_entries(self, content: str) -> List[str]:
        """Smart split t√¥n tr·ªçng quotes v√† nested structures"""
        entries = []
        current_entry = ""
        in_quotes = False
        quote_char = None
        bracket_depth = 0

        i = 0
        while i < len(content):
            char = content[i]

            if char in ['"', "'"] and (i == 0 or content[i-1] != '\\'):
                if not in_quotes:
                    in_quotes = True
                    quote_char = char
                elif char == quote_char:
                    in_quotes = False
                    quote_char = None

            elif not in_quotes:
                if char in ['[', '(']:
                    bracket_depth += 1
                elif char in [']', ')']:
                    bracket_depth -= 1
                elif char == ',' and bracket_depth == 0:
                    entries.append(current_entry)
                    current_entry = ""
                    i += 1
                    continue

            current_entry += char
            i += 1

        if current_entry.strip():
            entries.append(current_entry)

        return entries

    def validate_json_output(self, data: Dict[str, Any]) -> Tuple[bool, str]:
        """Validate JSON output tr∆∞·ªõc khi l∆∞u"""
        try:
            if not data:
                return False, "D·ªØ li·ªáu r·ªóng"

            if not isinstance(data, dict):
                return False, "D·ªØ li·ªáu kh√¥ng ph·∫£i dictionary"

            # Ki·ªÉm tra s·ªë l∆∞·ª£ng keys h·ª£p l√Ω
            if len(data) == 0:
                return False, "Kh√¥ng t√¨m th·∫•y keys"

            if len(data) > 10000:  # Sanity check
                return False, f"Qu√° nhi·ªÅu keys ({len(data)}), c√≥ th·ªÉ l·ªói parsing"

            # Test JSON serialization
            json.dumps(data, ensure_ascii=False, indent=2)

            return True, f"H·ª£p l·ªá v·ªõi {len(data)} keys"

        except Exception as e:
            return False, f"JSON validation th·∫•t b·∫°i: {e}"

    def convert_file_robust(self, php_file: Path) -> Tuple[bool, str, Dict[str, Any]]:
        """Convert file PHP v·ªõi robust error handling"""
        conversion_info = {
            'file': str(php_file),
            'analysis': {},
            'strategies_tried': [],
            'validation': {}
        }

        try:
            print(f"   üìÅ ƒêang x·ª≠ l√Ω: {php_file.name}")

            # Ph√¢n t√≠ch file tr∆∞·ªõc
            analysis = self.analyze_php_file(php_file)
            conversion_info['analysis'] = analysis

            if 'error' in analysis:
                return False, f"Ph√¢n t√≠ch file th·∫•t b·∫°i: {analysis['error']}", conversion_info

            print(f"      üìè K√≠ch th∆∞·ªõc: {analysis['file_size']} bytes, D√≤ng: {analysis['line_count']}")
            if analysis['variable_names']:
                print(f"      üî§ Bi·∫øn: {', '.join(analysis['variable_names'][:3])}{'...' if len(analysis['variable_names']) > 3 else ''}")

            # ƒê·ªçc n·ªôi dung file
            with open(php_file, 'r', encoding='utf-8') as f:
                content = f.read()

            # Th·ª≠ parsing v·ªõi nhi·ªÅu chi·∫øn l∆∞·ª£c
            data = self.parse_php_array_robust(content)

            if data is None:
                return False, "T·∫•t c·∫£ chi·∫øn l∆∞·ª£c parsing ƒë·ªÅu th·∫•t b·∫°i", conversion_info

            # Validate output
            is_valid, validation_msg = self.validate_json_output(data)
            conversion_info['validation'] = {'valid': is_valid, 'message': validation_msg}

            if not is_valid:
                return False, f"Validation th·∫•t b·∫°i: {validation_msg}", conversion_info

            print(f"      ‚úÖ ƒê√£ parse: {validation_msg}")

            # L∆∞u JSON file
            json_file = php_file.with_suffix('.json')
            with open(json_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)

            return True, validation_msg, conversion_info

        except Exception as e:
            return False, f"L·ªói conversion: {str(e)}", conversion_info

    def run_robust(self):
        """Ch·∫°y converter v·ªõi enhanced robustness"""
        print("üåç Robust PHP to JSON Language Converter (Ti·∫øng Vi·ªát)")
        print("=" * 65)

        count = self.find_php_files_recursive()

        if count == 0:
            print("‚úÖ Kh√¥ng t√¨m th·∫•y file PHP n√†o ƒë·ªÉ convert!")
            return

        print(f"\nüéØ Chi·∫øn l∆∞·ª£c x·ª≠ l√Ω:")
        print(f"   ‚Ä¢ Nhi·ªÅu parsing fallbacks")
        print(f"   ‚Ä¢ Validation chi ti·∫øt")
        print(f"   ‚Ä¢ X·ª≠ l√Ω an to√†n v·ªõi delay {self.processing_delay}s")
        print(f"   ‚Ä¢ Logging l·ªói to√†n di·ªán")

        choice = input(f"\nüî• X√≥a file .php sau khi convert th√†nh c√¥ng? (y/N): ").strip().lower()
        delete_php = choice in ['y', 'yes']

        if delete_php:
            confirm = input("‚ö†Ô∏è  B·∫°n c√≥ ch·∫Øc ch·∫Øn? Kh√¥ng th·ªÉ ho√†n t√°c (y/N): ").strip().lower()
            delete_php = confirm in ['y', 'yes']

        print(f"\nüîÑ B·∫Øt ƒë·∫ßu robust conversion {count} files...")
        print("=" * 65)

        failed_details = []

        for i, php_file in enumerate(self.php_files, 1):
            print(f"\nüìä [{i}/{count}] {php_file.relative_to(self.root_dir)}")

            success, message, info = self.convert_file_robust(php_file)

            if success:
                self.converted_count += 1
                print(f"   ‚úÖ {php_file.name} -> {php_file.stem}.json ({message})")

                if delete_php:
                    try:
                        php_file.unlink()
                        self.deleted_count += 1
                        print(f"   üóëÔ∏è  ƒê√£ x√≥a {php_file.name}")
                    except Exception as e:
                        print(f"   ‚ö†Ô∏è  Kh√¥ng th·ªÉ x√≥a {php_file.name}: {e}")
            else:
                self.failed_count += 1
                self.failed_files.append(php_file)
                failed_details.append({
                    'file': php_file.name,
                    'error': message,
                    'info': info
                })
                print(f"   ‚ùå {php_file.name}: {message}")

            # Delay nh·ªè ƒë·ªÉ an to√†n
            if self.processing_delay > 0:
                time.sleep(self.processing_delay)

        self._print_final_results(failed_details)

    def _print_final_results(self, failed_details: List[Dict]):
        """In k·∫øt qu·∫£ cu·ªëi c√πng to√†n di·ªán"""
        print(f"\n" + "=" * 65)
        print(f"üìä K·∫æT QU·∫¢ CU·ªêI C√ôNG:")
        print(f"   ‚úÖ Th√†nh c√¥ng: {self.converted_count} files")
        print(f"   ‚ùå Th·∫•t b·∫°i: {self.failed_count} files")

        if self.deleted_count > 0:
            print(f"   üóëÔ∏è  ƒê√£ x√≥a: {self.deleted_count} file PHP")

        if failed_details:
            print(f"\n‚ùå PH√ÇN T√çCH C√ÅC FILE TH·∫§T B·∫†I:")
            error_summary = {}
            for detail in failed_details:
                error_type = detail['error'].split(':')[0]
                error_summary[error_type] = error_summary.get(error_type, 0) + 1

            for error_type, count in error_summary.items():
                print(f"   ‚Ä¢ {error_type}: {count} files")

        success_rate = (self.converted_count / len(self.php_files)) * 100 if self.php_files else 0
        print(f"\nüéØ T·ª∑ l·ªá th√†nh c√¥ng: {success_rate:.1f}%")

        if success_rate < 90:
            print(f"\nüí° KHUY·∫æN NGH·ªä:")
            print(f"   ‚Ä¢ Ki·ªÉm tra c√°c file th·∫•t b·∫°i th·ªß c√¥ng ƒë·ªÉ t√¨m PHP syntax b·∫•t th∆∞·ªùng")
            print(f"   ‚Ä¢ M·ªôt s·ªë file c√≥ th·ªÉ c·∫ßn convert th·ªß c√¥ng")
            print(f"   ‚Ä¢ H√£y t·∫°o issue tr√™n GitHub v·ªõi sample c√°c file th·∫•t b·∫°i")

def main():
    try:
        converter = RobustPHPToJSONConverter()
        converter.run_robust()
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng")
    except Exception as e:
        print(f"‚ùå L·ªói nghi√™m tr·ªçng: {e}")

if __name__ == "__main__":
    main()
