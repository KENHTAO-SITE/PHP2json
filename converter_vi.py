#!/usr/bin/env python3
"""
Enterprise-Grade PHP Language Files to JSON Converter - Vietnamese Version
=========================================================================
C√¥ng c·ª• production-ready v·ªõi data integrity verification v√† backup system

T√≠nh nƒÉng:
- Data integrity verification gi·ªØa PHP v√† JSON
- H·ªá th·ªëng backup t·ª± ƒë·ªông tr∆∞·ªõc m·ªçi thao t√°c
- Deep comparison v√† validation c·ªßa d·ªØ li·ªáu converted
- C∆° ch·∫ø auto-retry cho conversions th·∫•t b·∫°i
- Enterprise-grade logging v√† audit trails
- Kh·∫£ nƒÉng rollback ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n
- Production-level error handling
"""

import os
import re
import json
import sys
import time
import shutil
from pathlib import Path
from typing import Dict, Any, Optional, Tuple, List
from datetime import datetime

class EnterprisePHPToJSONConverter:
    def __init__(self):
        self.root_dir = Path.cwd()
        self.php_files = []
        self.converted_count = 0
        self.failed_count = 0
        self.deleted_count = 0
        self.failed_files = []
        self.verified_files = []
        self.backup_dir = None
        self.processing_delay = 0.1
        self.max_retries = 3
        self.integrity_check_enabled = True

        # Enterprise logging
        self.setup_enterprise_logging()

    def setup_enterprise_logging(self):
        """Setup enterprise-grade logging system"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_dir = self.root_dir / "conversion_logs"
        self.log_dir.mkdir(exist_ok=True)

        self.conversion_log = self.log_dir / f"conversion_{timestamp}.log"
        self.integrity_log = self.log_dir / f"integrity_{timestamp}.log"
        self.backup_log = self.log_dir / f"backup_{timestamp}.log"

        print(f"üìã Enterprise logging ƒë√£ b·∫≠t:")
        print(f"   ‚Ä¢ Conversion log: {self.conversion_log.name}")
        print(f"   ‚Ä¢ Integrity log: {self.integrity_log.name}")
        print(f"   ‚Ä¢ Backup log: {self.backup_log.name}")

    def log_to_file(self, log_file: Path, level: str, message: str):
        """Ghi v√†o log file v·ªõi timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {level}: {message}\n"

        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(log_entry)

    def create_backup_system(self):
        """T·∫°o enterprise backup system"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.backup_dir = self.root_dir / f"backup_{timestamp}"
        self.backup_dir.mkdir(exist_ok=True)

        print(f"üõ°Ô∏è  Enterprise backup system ƒë√£ t·∫°o: {self.backup_dir.name}")
        self.log_to_file(self.backup_log, "INFO", f"Backup directory created: {self.backup_dir}")

        return self.backup_dir

    def backup_file(self, php_file: Path) -> bool:
        """T·∫°o backup c·ªßa PHP file tr∆∞·ªõc m·ªçi thao t√°c"""
        try:
            if not self.backup_dir:
                self.create_backup_system()

            # T·∫°o c·∫•u tr√∫c th∆∞ m·ª•c con trong backup
            relative_path = php_file.relative_to(self.root_dir)
            backup_file = self.backup_dir / relative_path
            backup_file.parent.mkdir(parents=True, exist_ok=True)

            # Copy file v√†o backup
            shutil.copy2(php_file, backup_file)

            self.log_to_file(self.backup_log, "SUCCESS", f"Backed up: {php_file} -> {backup_file}")
            return True

        except Exception as e:
            self.log_to_file(self.backup_log, "ERROR", f"Backup failed for {php_file}: {e}")
            return False

    def find_php_files_recursive(self, skip_existing=True):
        """T√¨m t·∫•t c·∫£ file .php v·ªõi ph√¢n t√≠ch chi ti·∫øt"""
        self.php_files = []

        print("üîç Enterprise scanning cho file PHP...")
        for php_file in self.root_dir.rglob("*.php"):
            if php_file.name in ["converter_en.py", "converter_vi.py", "load_json_example.php"]:
                continue

            if skip_existing:
                json_file = php_file.with_suffix('.json')
                if json_file.exists():
                    print(f"‚è≠Ô∏è  B·ªè qua {php_file.relative_to(self.root_dir)} (JSON ƒë√£ t·ªìn t·∫°i)")
                    continue

            self.php_files.append(php_file)

        print(f"üìä T√¨m th·∫•y {len(self.php_files)} file PHP cho enterprise processing")
        self.log_to_file(self.conversion_log, "INFO", f"Found {len(self.php_files)} PHP files to process")
        return len(self.php_files)

    def analyze_php_file(self, php_file: Path) -> Dict[str, Any]:
        """Ph√¢n t√≠ch c·∫•u tr√∫c file PHP tr∆∞·ªõc khi convert"""
        try:
            with open(php_file, 'r', encoding='utf-8') as f:
                content = f.read()

            analysis = {
                'file_size': len(content),
                'line_count': content.count('\n') + 1,
                'has_php_tags': '<?php' in content or '<?=' in content,
                'has_return_statement': re.search(r'\breturn\s+', content, re.IGNORECASE) is not None,
                'has_variable_assignment': re.search(r'\$\w+\s*=', content) is not None,
                'array_syntax': [],
                'variable_names': [],
                'encoding': 'utf-8',
                'content_hash': hash(content)  # Cho integrity verification
            }

            # Ph√°t hi·ªán lo·∫°i array syntax
            if re.search(r'\[.*?\]', content, re.DOTALL):
                analysis['array_syntax'].append('short_array')
            if re.search(r'array\s*\(', content, re.IGNORECASE):
                analysis['array_syntax'].append('long_array')

            # Tr√≠ch xu·∫•t t√™n bi·∫øn
            var_matches = re.findall(r'\$(\w+)\s*=', content)
            analysis['variable_names'] = list(set(var_matches))

            return analysis

        except Exception as e:
            return {'error': str(e)}

    def parse_php_array_robust(self, content: str) -> Optional[Dict[str, Any]]:
        """Parsing PHP ƒëa chi·∫øn l∆∞·ª£c v·ªõi fallbacks to√†n di·ªán"""

        # Chi·∫øn l∆∞·ª£c 1: Advanced regex v·ªõi h·ªó tr·ª£ nested structure
        result = self._parse_strategy_advanced_regex(content)
        if result and len(result) > 0:
            return result

        # Chi·∫øn l∆∞·ª£c 2: Tokenizer gi·ªëng PHP
        result = self._parse_strategy_tokenizer(content)
        if result and len(result) > 0:
            return result

        # Chi·∫øn l∆∞·ª£c 3: Line-by-line v·ªõi state machine
        result = self._parse_strategy_state_machine(content)
        if result and len(result) > 0:
            return result

        # Chi·∫øn l∆∞·ª£c 4: Regex v·ªõi x·ª≠ l√Ω nested th·ªß c√¥ng
        result = self._parse_strategy_manual_nested(content)
        if result and len(result) > 0:
            return result

        return None

    def _parse_strategy_advanced_regex(self, content: str) -> Optional[Dict[str, Any]]:
        """Chi·∫øn l∆∞·ª£c 1: Advanced regex parsing"""
        try:
            content = self._clean_php_content(content)

            patterns = [
                r'return\s*\[(.*?)\];',
                r'return\s*array\s*\((.*?)\);',
                r'\$(?:lang|language|data|translations|messages|text|strings)\s*=\s*\[(.*?)\];',
                r'\$(?:lang|language|data|translations|messages|text|strings)\s*=\s*array\s*\((.*?)\);',
            ]

            for pattern in patterns:
                match = re.search(pattern, content, re.DOTALL | re.IGNORECASE)
                if match:
                    array_content = match.group(1)
                    result = self._parse_array_content_advanced(array_content)
                    if result:
                        return result

        except Exception as e:
            print(f"   ‚ö†Ô∏è  Chi·∫øn l∆∞·ª£c 1 th·∫•t b·∫°i: {e}")

        return None

    def _parse_strategy_tokenizer(self, content: str) -> Optional[Dict[str, Any]]:
        """Chi·∫øn l∆∞·ª£c 2: Tokenizer approach"""
        try:
            content = self._clean_php_content(content)
            result = {}

            array_start = None
            for pattern in [r'return\s*\[', r'return\s*array\s*\(', r'\$\w+\s*=\s*\[', r'\$\w+\s*=\s*array\s*\(']:
                match = re.search(pattern, content, re.IGNORECASE)
                if match:
                    array_start = match.end()
                    break

            if array_start is None:
                return None

            remaining_content = content[array_start:]

            kv_pattern = r"""
                (?:^|,|\n)\s*                    # B·∫Øt ƒë·∫ßu ho·∫∑c separator
                (['\"])((?:\\.|(?!\1)[^\\])*?)\1  # Quoted key
                \s*=>\s*                         # M≈©i t√™n
                (?:
                    (['\"])((?:\\.|(?!\3)[^\\])*?)\3  # Quoted value
                    |
                    (\d+(?:\.\d+)?)              # S·ªë
                    |
                    (true|false|null)            # Boolean/null
                    |
                    (\[(?:[^\[\]]|(?7))*\])      # Simple nested array
                )
            """

            matches = re.finditer(kv_pattern, remaining_content, re.VERBOSE | re.DOTALL | re.IGNORECASE)

            for match in matches:
                groups = match.groups()
                if len(groups) >= 4:
                    key = self._clean_string_value(groups[1])

                    if groups[3]:  # String value
                        value = self._clean_string_value(groups[3])
                    elif groups[4]:  # Number
                        value = groups[4]
                    elif groups[5]:  # Boolean/null
                        value = groups[5].lower()
                    elif groups[6]:  # Nested array
                        value = groups[6]
                    else:
                        continue

                    result[key] = value

            return result if result else None

        except Exception as e:
            print(f"   ‚ö†Ô∏è  Chi·∫øn l∆∞·ª£c 2 th·∫•t b·∫°i: {e}")

        return None

    def _parse_strategy_state_machine(self, content: str) -> Optional[Dict[str, Any]]:
        """Chi·∫øn l∆∞·ª£c 3: State machine line-by-line parsing"""
        try:
            content = self._clean_php_content(content)
            lines = content.split('\n')
            result = {}

            in_array = False
            current_key = None
            current_value = ""

            for line_no, line in enumerate(lines, 1):
                line = line.strip()

                if not line or line.startswith('//') or line.startswith('/*'):
                    continue

                if not in_array and ('=>' in line or re.search(r'return\s*[\[\(]|^\$\w+\s*=\s*[\[\(]', line)):
                    in_array = True

                if not in_array:
                    continue

                if '=>' in line and current_key is None:
                    parts = line.split('=>', 1)
                    if len(parts) == 2:
                        key_part = parts[0].strip()
                        value_part = parts[1].strip()

                        key_match = re.search(r"['\"]([^'\"]*)['\"]", key_part)
                        if key_match:
                            current_key = self._clean_string_value(key_match.group(1))

                            value_match = re.search(r"['\"]([^'\"]*)['\"]", value_part)
                            if value_match:
                                result[current_key] = self._clean_string_value(value_match.group(1))
                                current_key = None
                            else:
                                current_value = value_part

            return result if result else None

        except Exception as e:
            print(f"   ‚ö†Ô∏è  Chi·∫øn l∆∞·ª£c 3 th·∫•t b·∫°i: {e}")

        return None

    def _parse_strategy_manual_nested(self, content: str) -> Optional[Dict[str, Any]]:
        """Chi·∫øn l∆∞·ª£c 4: X·ª≠ l√Ω nested structure th·ªß c√¥ng"""
        try:
            content = self._clean_php_content(content)
            result = {}

            pattern = r"""
                (['\"])((?:\\.|(?!\1)[^\\])*?)\1    # Key trong quotes
                \s*=>\s*                            # M≈©i t√™n
                (?:
                    (['\"])((?:\\.|(?!\3)[^\\])*?)\3 # Simple quoted value
                    |
                    (\d+(?:\.\d+)?)                 # Numeric value
                    |
                    (true|false|null)               # Boolean/null
                    |
                    (\[(?:[^\[\]]++|(?7))*+\])      # Nested array (possessive)
                )
            """

            matches = re.finditer(pattern, content, re.VERBOSE | re.DOTALL | re.IGNORECASE)

            for match in matches:
                try:
                    key_quote, key, value_quote, value, numeric, boolean, nested = match.groups()

                    clean_key = self._clean_string_value(key)

                    if value is not None:
                        clean_value = self._clean_string_value(value)
                    elif numeric is not None:
                        clean_value = numeric
                    elif boolean is not None:
                        clean_value = boolean.lower()
                    elif nested is not None:
                        clean_value = self._parse_nested_array(nested) or nested
                    else:
                        continue

                    result[clean_key] = clean_value

                except Exception as e:
                    print(f"   ‚ö†Ô∏è  L·ªói parsing match: {e}")
                    continue

            return result if result else None

        except Exception as e:
            print(f"   ‚ö†Ô∏è  Chi·∫øn l∆∞·ª£c 4 th·∫•t b·∫°i: {e}")

        return None

    def _clean_php_content(self, content: str) -> str:
        """L√†m s·∫°ch PHP content ƒë·ªÉ parsing"""
        content = re.sub(r'<\?php\s*', '', content)
        content = re.sub(r'\?>', '', content)
        content = re.sub(r'//.*?$', '', content, flags=re.MULTILINE)
        content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
        content = re.sub(r'#.*?$', '', content, flags=re.MULTILINE)

        return content.strip()

    def _clean_string_value(self, value: str) -> str:
        """L√†m s·∫°ch string value b·∫±ng c√°ch x√≥a escapes"""
        if not value:
            return value

        value = value.replace('\\"', '"')
        value = value.replace("\\'", "'")
        value = value.replace('\\\\', '\\')

        return value

    def _parse_nested_array(self, nested_content: str) -> Optional[str]:
        """Parse nested array content"""
        try:
            nested_content = nested_content.strip('[]()').strip()
            return nested_content
        except:
            return None

    def _parse_array_content_advanced(self, array_content: str) -> Optional[Dict[str, Any]]:
        """Advanced array content parsing"""
        result = {}

        try:
            entries = self._smart_split_array_entries(array_content)

            for entry in entries:
                entry = entry.strip()
                if not entry or entry.startswith('//'):
                    continue

                if '=>' in entry:
                    parts = entry.split('=>', 1)
                    if len(parts) == 2:
                        key_part = parts[0].strip()
                        value_part = parts[1].strip()

                        key_match = re.search(r"['\"]([^'\"]*)['\"]", key_part)
                        if key_match:
                            key = self._clean_string_value(key_match.group(1))

                            value_match = re.search(r"['\"]([^'\"]*)['\"]", value_part)
                            if value_match:
                                value = self._clean_string_value(value_match.group(1))
                                result[key] = value

        except Exception as e:
            print(f"   ‚ö†Ô∏è  Advanced parsing th·∫•t b·∫°i: {e}")

        return result if result else None

    def _smart_split_array_entries(self, content: str) -> List[str]:
        """Smart split t√¥n tr·ªçng quotes v√† nested structures"""
        entries = []
        current_entry = ""
        in_quotes = False
        quote_char = None
        bracket_depth = 0

        i = 0
        while i < len(content):
            char = content[i]

            if char in ['"', "'"] and (i == 0 or content[i-1] != '\\'):
                if not in_quotes:
                    in_quotes = True
                    quote_char = char
                elif char == quote_char:
                    in_quotes = False
                    quote_char = None

            elif not in_quotes:
                if char in ['[', '(']:
                    bracket_depth += 1
                elif char in [']', ')']:
                    bracket_depth -= 1
                elif char == ',' and bracket_depth == 0:
                    entries.append(current_entry)
                    current_entry = ""
                    i += 1
                    continue

            current_entry += char
            i += 1

        if current_entry.strip():
            entries.append(current_entry)

        return entries

    def validate_json_output(self, data: Dict[str, Any]) -> Tuple[bool, str]:
        """Validate JSON output tr∆∞·ªõc khi l∆∞u"""
        try:
            if not data:
                return False, "D·ªØ li·ªáu r·ªóng"

            if not isinstance(data, dict):
                return False, "D·ªØ li·ªáu kh√¥ng ph·∫£i dictionary"

            if len(data) == 0:
                return False, "Kh√¥ng t√¨m th·∫•y keys"

            if len(data) > 10000:
                return False, f"Qu√° nhi·ªÅu keys ({len(data)}), c√≥ th·ªÉ l·ªói parsing"

            json.dumps(data, ensure_ascii=False, indent=2)

            return True, f"H·ª£p l·ªá v·ªõi {len(data)} keys"

        except Exception as e:
            return False, f"JSON validation th·∫•t b·∫°i: {e}"

    def verify_data_integrity(self, php_file: Path, json_file: Path, original_data: Dict[str, Any]) -> Tuple[bool, str, Dict[str, Any]]:
        """Enterprise-grade data integrity verification"""
        integrity_report = {
            'php_file': str(php_file),
            'json_file': str(json_file),
            'verification_time': datetime.now().isoformat(),
            'checks_performed': [],
            'issues_found': [],
            'data_match': False,
            'key_count_match': False,
            'content_hash_match': False
        }

        try:
            print(f"      üîç Ki·ªÉm tra t√≠nh to√†n v·∫πn d·ªØ li·ªáu...")

            # Ki·ªÉm tra 1: JSON file t·ªìn t·∫°i v√† ƒë·ªçc ƒë∆∞·ª£c
            if not json_file.exists():
                integrity_report['issues_found'].append("JSON file kh√¥ng t·ªìn t·∫°i")
                return False, "JSON file b·ªã thi·∫øu", integrity_report

            with open(json_file, 'r', encoding='utf-8') as f:
                json_data = json.load(f)
            integrity_report['checks_performed'].append("JSON file readability")

            # Ki·ªÉm tra 2: So s√°nh s·ªë l∆∞·ª£ng key
            original_key_count = len(original_data)
            json_key_count = len(json_data)

            if original_key_count != json_key_count:
                integrity_report['issues_found'].append(f"S·ªë key kh√¥ng kh·ªõp: PHP={original_key_count}, JSON={json_key_count}")
            else:
                integrity_report['key_count_match'] = True
            integrity_report['checks_performed'].append("Key count comparison")

            # Ki·ªÉm tra 3: Deep key-value comparison
            missing_keys = []
            value_mismatches = []

            for key, php_value in original_data.items():
                if key not in json_data:
                    missing_keys.append(key)
                elif str(json_data[key]) != str(php_value):
                    value_mismatches.append({
                        'key': key,
                        'php_value': php_value,
                        'json_value': json_data[key]
                    })

            # Ki·ªÉm tra key th·ª´a trong JSON
            extra_keys = [key for key in json_data.keys() if key not in original_data]

            if missing_keys:
                integrity_report['issues_found'].append(f"Key thi·∫øu trong JSON: {missing_keys}")
            if extra_keys:
                integrity_report['issues_found'].append(f"Key th·ª´a trong JSON: {extra_keys}")
            if value_mismatches:
                integrity_report['issues_found'].append(f"Value kh√¥ng kh·ªõp: {len(value_mismatches)} ph√°t hi·ªán")

            integrity_report['checks_performed'].append("Deep key-value comparison")

            # Ki·ªÉm tra 4: Content hash verification
            json_content_hash = hash(json.dumps(json_data, sort_keys=True))
            php_content_hash = hash(json.dumps(original_data, sort_keys=True))

            if json_content_hash == php_content_hash:
                integrity_report['content_hash_match'] = True
            integrity_report['checks_performed'].append("Content hash verification")

            # ƒê√°nh gi√° cu·ªëi c√πng
            data_integrity_passed = (
                integrity_report['key_count_match'] and
                len(missing_keys) == 0 and
                len(extra_keys) == 0 and
                len(value_mismatches) == 0
            )

            integrity_report['data_match'] = data_integrity_passed

            if data_integrity_passed:
                print(f"      ‚úÖ T√≠nh to√†n v·∫πn d·ªØ li·ªáu x√°c minh: 100% kh·ªõp")
                self.log_to_file(self.integrity_log, "SUCCESS", f"Data integrity verified for {php_file}")
                return True, "T√≠nh to√†n v·∫πn d·ªØ li·ªáu ƒë∆∞·ª£c x√°c minh", integrity_report
            else:
                print(f"      ‚ùå Ph√°t hi·ªán v·∫•n ƒë·ªÅ t√≠nh to√†n v·∫πn: {len(integrity_report['issues_found'])} v·∫•n ƒë·ªÅ")
                self.log_to_file(self.integrity_log, "FAILED", f"Data integrity issues for {php_file}: {integrity_report['issues_found']}")
                return False, f"T√≠nh to√†n v·∫πn th·∫•t b·∫°i: {len(integrity_report['issues_found'])} v·∫•n ƒë·ªÅ", integrity_report

        except Exception as e:
            integrity_report['issues_found'].append(f"L·ªói verification: {str(e)}")
            self.log_to_file(self.integrity_log, "ERROR", f"Data integrity verification error for {php_file}: {e}")
            return False, f"L·ªói verification: {str(e)}", integrity_report

    def auto_retry_conversion(self, php_file: Path, max_retries: int = 3) -> Tuple[bool, str, Dict[str, Any], Dict[str, Any]]:
        """C∆° ch·∫ø auto-retry cho conversions th·∫•t b·∫°i"""
        for attempt in range(1, max_retries + 1):
            print(f"      üîÑ L·∫ßn th·ª≠ conversion {attempt}/{max_retries}")

            try:
                with open(php_file, 'r', encoding='utf-8') as f:
                    content = f.read()

                data = self.parse_php_array_robust(content)

                if data is not None:
                    is_valid, validation_msg = self.validate_json_output(data)
                    if is_valid:
                        return True, validation_msg, data, {'attempts': attempt}

                print(f"      ‚ö†Ô∏è  L·∫ßn th·ª≠ {attempt} th·∫•t b·∫°i, ƒëang retry...")
                time.sleep(0.2 * attempt)  # Progressive delay

            except Exception as e:
                print(f"      ‚ùå L·∫ßn th·ª≠ {attempt} l·ªói: {e}")

        return False, f"T·∫•t c·∫£ {max_retries} l·∫ßn th·ª≠ conversion ƒë·ªÅu th·∫•t b·∫°i", {}, {'attempts': max_retries}

    def convert_file_enterprise(self, php_file: Path) -> Tuple[bool, str, Dict[str, Any]]:
        """Enterprise-grade file conversion v·ªõi full integrity checking"""
        conversion_info = {
            'file': str(php_file),
            'analysis': {},
            'strategies_tried': [],
            'validation': {},
            'integrity': {},
            'backup_created': False,
            'retry_attempts': 0
        }

        try:
            print(f"   üìÅ Enterprise processing: {php_file.name}")

            # B∆∞·ªõc 1: T·∫°o backup
            backup_success = self.backup_file(php_file)
            conversion_info['backup_created'] = backup_success

            if not backup_success:
                return False, "T·∫°o backup th·∫•t b·∫°i - h·ªßy b·ªè ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n", conversion_info

            # B∆∞·ªõc 2: Ph√¢n t√≠ch file
            analysis = self.analyze_php_file(php_file)
            conversion_info['analysis'] = analysis

            if 'error' in analysis:
                return False, f"Ph√¢n t√≠ch file th·∫•t b·∫°i: {analysis['error']}", conversion_info

            print(f"      üìè K√≠ch th∆∞·ªõc: {analysis['file_size']} bytes, D√≤ng: {analysis['line_count']}")
            if analysis['variable_names']:
                print(f"      üî§ Bi·∫øn: {', '.join(analysis['variable_names'][:3])}{'...' if len(analysis['variable_names']) > 3 else ''}")

            # B∆∞·ªõc 3: Convert v·ªõi auto-retry
            success, message, data, retry_info = self.auto_retry_conversion(php_file, self.max_retries)
            conversion_info['retry_attempts'] = retry_info.get('attempts', 0)

            if not success:
                return False, message, conversion_info

            # B∆∞·ªõc 4: Validate JSON output
            is_valid, validation_msg = self.validate_json_output(data)
            conversion_info['validation'] = {'valid': is_valid, 'message': validation_msg}

            if not is_valid:
                return False, f"Validation th·∫•t b·∫°i: {validation_msg}", conversion_info

            print(f"      ‚úÖ Conversion th√†nh c√¥ng: {validation_msg}")

            # B∆∞·ªõc 5: L∆∞u JSON file
            json_file = php_file.with_suffix('.json')
            with open(json_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)

            # B∆∞·ªõc 6: Enterprise data integrity verification
            if self.integrity_check_enabled:
                integrity_passed, integrity_msg, integrity_report = self.verify_data_integrity(
                    php_file, json_file, data
                )
                conversion_info['integrity'] = integrity_report

                if not integrity_passed:
                    # X√≥a JSON file c√≥ th·ªÉ b·ªã corrupted
                    if json_file.exists():
                        json_file.unlink()
                    return False, f"Ki·ªÉm tra t√≠nh to√†n v·∫πn th·∫•t b·∫°i: {integrity_msg}", conversion_info

                self.verified_files.append(php_file)

            self.log_to_file(self.conversion_log, "SUCCESS", f"Enterprise conversion completed: {php_file}")
            return True, f"{validation_msg} + t√≠nh to√†n v·∫πn ƒë√£ x√°c minh", conversion_info

        except Exception as e:
            self.log_to_file(self.conversion_log, "ERROR", f"Enterprise conversion error for {php_file}: {e}")
            return False, f"L·ªói enterprise conversion: {str(e)}", conversion_info

    def safe_delete_php_file(self, php_file: Path) -> bool:
        """X√≥a PHP file an to√†n v·ªõi nhi·ªÅu l·∫ßn x√°c nh·∫≠n"""
        try:
            # Ki·ªÉm tra t√≠nh to√†n v·∫πn cu·ªëi c√πng tr∆∞·ªõc khi x√≥a
            json_file = php_file.with_suffix('.json')

            if not json_file.exists():
                print(f"      ‚ùå JSON file thi·∫øu, kh√¥ng th·ªÉ x√≥a {php_file.name}")
                return False

            # ƒê·ªçc v√† verify JSON file m·ªôt l·∫ßn n·ªØa
            with open(json_file, 'r', encoding='utf-8') as f:
                json_data = json.load(f)

            if not json_data or len(json_data) == 0:
                print(f"      ‚ùå JSON file r·ªóng, kh√¥ng th·ªÉ x√≥a {php_file.name}")
                return False

            # X√≥a an to√†n
            php_file.unlink()
            self.log_to_file(self.conversion_log, "DELETE", f"Safely deleted PHP file: {php_file}")
            return True

        except Exception as e:
            self.log_to_file(self.conversion_log, "ERROR", f"Safe deletion failed for {php_file}: {e}")
            return False

    def run_enterprise(self):
        """Ch·∫°y enterprise-grade converter"""
        print("üè¢ Enterprise PHP to JSON Language Converter (Ti·∫øng Vi·ªát)")
        print("=" * 75)

        count = self.find_php_files_recursive()

        if count == 0:
            print("‚úÖ Kh√¥ng t√¨m th·∫•y file PHP n√†o cho enterprise processing!")
            return

        print(f"\nüéØ T√≠nh nƒÉng Enterprise Processing:")
        print(f"   ‚Ä¢ H·ªá th·ªëng backup t·ª± ƒë·ªông")
        print(f"   ‚Ä¢ Data integrity verification")
        print(f"   ‚Ä¢ Auto-retry v·ªõi {self.max_retries} l·∫ßn th·ª≠")
        print(f"   ‚Ä¢ Deep comparison PHP ‚Üî JSON")
        print(f"   ‚Ä¢ Enterprise logging v√† audit trails")
        print(f"   ‚Ä¢ Safe deletion v·ªõi nhi·ªÅu l·∫ßn x√°c nh·∫≠n")

        # Enterprise-grade confirmation
        choice = input(f"\nüî• B·∫≠t safe deletion sau integrity verification? (y/N): ").strip().lower()
        delete_php = choice in ['y', 'yes']

        if delete_php:
            confirm1 = input("‚ö†Ô∏è  Enterprise deletion c·∫ßn backup verification. Ti·∫øp t·ª•c? (y/N): ").strip().lower()
            if confirm1 not in ['y', 'yes']:
                delete_php = False
            else:
                confirm2 = input("üõ°Ô∏è  X√°c nh·∫≠n cu·ªëi: X√≥a file PHP sau 100% integrity verification? (y/N): ").strip().lower()
                delete_php = confirm2 in ['y', 'yes']

        print(f"\nüîÑ B·∫Øt ƒë·∫ßu enterprise conversion {count} files...")
        print("=" * 75)

        failed_details = []
        integrity_failures = []

        for i, php_file in enumerate(self.php_files, 1):
            print(f"\nüìä [{i}/{count}] {php_file.relative_to(self.root_dir)}")

            success, message, info = self.convert_file_enterprise(php_file)

            if success:
                self.converted_count += 1
                print(f"   ‚úÖ {php_file.name} -> {php_file.stem}.json ({message})")

                if delete_php:
                    if self.safe_delete_php_file(php_file):
                        self.deleted_count += 1
                        print(f"   üóëÔ∏è  ƒê√£ x√≥a an to√†n {php_file.name}")
                    else:
                        print(f"   ‚ö†Ô∏è  Kh√¥ng th·ªÉ x√≥a an to√†n {php_file.name}")
            else:
                self.failed_count += 1
                self.failed_files.append(php_file)

                # Ki·ªÉm tra n·∫øu l√† integrity failure
                if 'integrity' in info and not info['integrity'].get('data_match', False):
                    integrity_failures.append(php_file)

                failed_details.append({
                    'file': php_file.name,
                    'error': message,
                    'info': info
                })
                print(f"   ‚ùå {php_file.name}: {message}")

            if self.processing_delay > 0:
                time.sleep(self.processing_delay)

        self._print_enterprise_results(failed_details, integrity_failures)

    def _print_enterprise_results(self, failed_details: List[Dict], integrity_failures: List[Path]):
        """In k·∫øt qu·∫£ enterprise to√†n di·ªán"""
        print(f"\n" + "=" * 75)
        print(f"üè¢ K·∫æT QU·∫¢ ENTERPRISE CONVERSION:")
        print(f"   ‚úÖ Convert th√†nh c√¥ng: {self.converted_count} files")
        print(f"   üîç Integrity ƒë√£ verify: {len(self.verified_files)} files")
        print(f"   ‚ùå Conversion th·∫•t b·∫°i: {self.failed_count} files")
        print(f"   ‚ö†Ô∏è  Integrity th·∫•t b·∫°i: {len(integrity_failures)} files")

        if self.deleted_count > 0:
            print(f"   üóëÔ∏è  ƒê√£ x√≥a an to√†n: {self.deleted_count} file PHP")

        if self.backup_dir:
            print(f"   üõ°Ô∏è  Th∆∞ m·ª•c backup: {self.backup_dir.name}")

        if failed_details:
            print(f"\n‚ùå PH√ÇN T√çCH TH·∫§T B·∫†I:")
            error_summary = {}
            for detail in failed_details:
                error_type = detail['error'].split(':')[0]
                error_summary[error_type] = error_summary.get(error_type, 0) + 1

            for error_type, count in error_summary.items():
                print(f"   ‚Ä¢ {error_type}: {count} files")

        success_rate = (self.converted_count / len(self.php_files)) * 100 if self.php_files else 0
        integrity_rate = (len(self.verified_files) / len(self.php_files)) * 100 if self.php_files else 0

        print(f"\nüìä ENTERPRISE METRICS:")
        print(f"   üéØ T·ª∑ l·ªá Conversion th√†nh c√¥ng: {success_rate:.1f}%")
        print(f"   üîç T·ª∑ l·ªá Data Integrity: {integrity_rate:.1f}%")
        print(f"   üìã Log Files: {self.log_dir.name}/")

        if success_rate < 100:
            print(f"\nüí° KHUY·∫æN NGH·ªä ENTERPRISE:")
            print(f"   ‚Ä¢ Review c√°c file th·∫•t b·∫°i trong conversion logs")
            print(f"   ‚Ä¢ Ki·ªÉm tra integrity failures ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n d·ªØ li·ªáu")
            print(f"   ‚Ä¢ Th∆∞ m·ª•c backup ch·ª©a file g·ªëc ƒë·ªÉ recovery")
            print(f"   ‚Ä¢ C√¢n nh·∫Øc review th·ªß c√¥ng c√°c c·∫•u tr√∫c PHP ph·ª©c t·∫°p")

        # Hi·ªÉn th·ªã credit banner ƒë·∫πp sau k·∫øt qu·∫£
        self._show_credit_banner()

    def _show_credit_banner(self):
        """Hi·ªÉn th·ªã credit banner ƒë·∫πp v·ªõi th√¥ng tin li√™n h·ªá"""
        print(f"\n" + "‚ïê" * 75)
        print("‚ïî" + "‚ïê" * 73 + "‚ïó")
        print("‚ïë" + " " * 73 + "‚ïë")
        print("‚ïë" + "   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó".center(73) + "‚ïë")
        print("‚ïë" + "   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë".center(73) + "‚ïë")
        print("‚ïë" + "   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë".center(73) + "‚ïë")
        print("‚ïë" + "   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë".center(73) + "‚ïë")
        print("‚ïë" + "   ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë".center(73) + "‚ïë")
        print("‚ïë" + "   ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù".center(73) + "‚ïë")
        print("‚ïë" + " " * 73 + "‚ïë")
        print("‚ïë" + "üöÄ ENTERPRISE PHP TO JSON LANGUAGE CONVERTER üöÄ".center(73) + "‚ïë")
        print("‚ïë" + " " * 73 + "‚ïë")
        print("‚ïë" + "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ".center(73) + "‚ïë")
        print("‚ïë" + " " * 73 + "‚ïë")
        print("‚ïë" + "üéØ T·∫†O B·ªûI: K√äNH T√ÅO".center(73) + "‚ïë")
        print("‚ïë" + " " * 73 + "‚ïë")
        print("‚ïë" + "üì± TELEGRAM: @QTUNUy".center(73) + "‚ïë")
        print("‚ïë" + " " * 73 + "‚ïë")
        print("‚ïë" + "üåê WEBSITES:".center(73) + "‚ïë")
        print("‚ïë" + "‚Ä¢ CertApple.com  ‚Ä¢ Kenhtao.net  ‚Ä¢ kenhtao.site  ‚Ä¢ iPA.KenhTao.net".center(73) + "‚ïë")
        print("‚ïë" + " " * 73 + "‚ïë")
        print("‚ïë" + "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ".center(73) + "‚ïë")
        print("‚ïë" + " " * 73 + "‚ïë")
        print("‚ïë" + "üíù C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng PHP2JSON Enterprise Converter! üíù".center(73) + "‚ïë")
        print("‚ïë" + "‚≠ê N·∫øu tool n√†y h·ªØu √≠ch, h√£y star GitHub repository c·ªßa ch√∫ng t√¥i ‚≠ê".center(73) + "‚ïë")
        print("‚ïë" + " " * 73 + "‚ïë")
        print("‚ïë" + "üîî ƒê·ªÉ nh·∫≠n updates v√† support, h√£y follow Telegram: @QTUNUy üîî".center(73) + "‚ïë")
        print("‚ïë" + " " * 73 + "‚ïë")
        print("‚ïö" + "‚ïê" * 73 + "‚ïù")
        print("‚ïê" * 75)

def main():
    try:
        converter = EnterprisePHPToJSONConverter()
        converter.run_enterprise()
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Enterprise conversion b·ªã d·ª´ng l·∫°i b·ªüi user")
    except Exception as e:
        print(f"‚ùå L·ªói enterprise system: {e}")

if __name__ == "__main__":
    main()
